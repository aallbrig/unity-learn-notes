Mind Map generated by NB MindMap plugin
> __version__=`1.1`,showJumps=`true`
---

# C\# Scripting in Unity: Beyond the Basics
> collapsed=`true`


## Tips
> collapsed=`true`


### Consistency trumps style
> collapsed=`true`


#### conventions

### Code is written for people to read

### Think about logical groupings as paragraphs in an essay

### Make names descriptive and consistent

### Use easily readable names

### Avoid abbreviations

### Do not use underscores between words

### Namespaces are typically grouped by feature \(see Unity namespaces for examples\)

## Common Naming Conventions
> collapsed=`true`,leftSide=`true`


### Pascal Case
> collapsed=`true`


#### The first letter of every word is capitalized

#### One word identifiers are always capitalized
> leftSide=`true`


### Camel Case
> collapsed=`true`


#### The first letter of the first word is lowercase

#### All subsequent words have the first letter capitalized
> leftSide=`true`


## Understanding Types
> collapsed=`true`,leftSide=`true`


### Components of a Program
> collapsed=`true`


#### Data
> collapsed=`true`


##### Information to be processed & stored

#### Logic
> collapsed=`true`


##### Operations to be performed on data

### What can a type tell us?
> collapsed=`true`


#### The kind of data stored

#### Amount of memory required
> leftSide=`true`


#### The location in memory
> leftSide=`true`


### Types of types
> collapsed=`true`


#### Value types
> collapsed=`true`


##### Memory is allocated directly and inline on the stack

#### Reference types
> collapsed=`true`,leftSide=`true`


##### Memory is allocated randomly on the managed heap

##### e\.g\. classes, delegates and interfaces

### Memory allocation by type
> collapsed=`true`


#### Stack
> collapsed=`true`


##### Value types

##### Pointers to reference types

#### Heap
> collapsed=`true`,leftSide=`true`


##### Reference types

### Stack vs heap
> collapsed=`true`


#### Stack
> collapsed=`true`


##### Allocated when compiled

##### Data is stored sequentially

##### Variable size must be known

##### Not subject to garbage collection

##### Fast

#### Heap
> collapsed=`true`,leftSide=`true`


##### Allocated during runtime

##### Data is stored randomly

##### Variable size can be unknown

##### May be garbage collected

##### Slow

### Anonymous type
> collapsed=`true`


#### e\.g\. var enemy = new \{ name = "Monster", health = 100 \}

### Generics
> collapsed=`true`


#### May replace method overloading

## Groups of Types
> collapsed=`true`


### Arrays
> collapsed=`true`


#### fixed length

#### more performant

### Generic lists
> collapsed=`true`


#### variable length

#### able to be sorted

### Dictionaries
> collapsed=`true`


#### key/value

### Queues and stacks
> collapsed=`true`


#### designed for transiant data

#### elements added are removed on use

#### Queue
> collapsed=`true`


##### First in, first out \(FIFO\)

##### Head, tail

##### dequeue removes from head

##### queue adds to tail

##### a runtime error is thrown if no elements are in queue when dequeue\(\) is called

#### Stacks
> collapsed=`true`


##### First in, last out \(FILO\)

##### elements are pushed to the top of the stack

##### elements are poped from the top of the stack

## Coroutines
> leftSide=`true`


### What are coroutines?

### What are they used for?

### I like to think of coroutines as todo lists that can sequentially execute

### Can delay execution

### Coroutines use scale time\. If you update Time\.scaleTime = 0, but want a coroutine to ignore that scale, use new WaitForSecondsRealtime\(\) instead of WaitForSeconds\(\)

### Parallel execution

#### Update runs once per frame, sequentially, before advancing to the next frame

#### Coroutines allow execution to happen over multiple frames

### Let you create time based behaviours
